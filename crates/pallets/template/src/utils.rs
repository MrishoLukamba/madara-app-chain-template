
use crate::*;
pub use utils::*;
pub mod utils {
    use codec::{Decode, Encode, MaxEncodedLen};
    use frame_support::ensure;
    use frame_support::pallet_prelude::DispatchResult;
    use scale_info::TypeInfo;
    use super::*;

    /// Candidate data structure
    #[derive(Encode, Decode, Clone,TypeInfo,MaxEncodedLen)]
    pub struct Candidate<T: Config> {
        pub account_id: T::AccountId,
        pub name: Vec<u8>,
        pub institutions: Vec<T::AccountId>,
    }

    /// institution data structure
    #[derive(Encode, Decode, Clone,TypeInfo,MaxEncodedLen)]
    pub struct Institution<T: Config> {
        pub account_id: T::AccountId,
        pub name: Vec<u8>,
    }

    /// Skills to be added in the certificate and verified by the institution
    #[derive(Encode, Decode, Clone,TypeInfo,MaxEncodedLen)]
    pub struct Skills<T: Config> {
        pub skill_name: Vec<u8>,
        pub skill_id: Vec<u8>,
        pub skill_level: u8,
        pub description: Vec<u8>,
        pub institution_id: T::AccountId,
        pub verified: bool,
    }


    /// Certificate data structure
    #[derive(Encode, Decode, Clone,TypeInfo,MaxEncodedLen)]
    pub struct Certificate<T: Config> {
        pub account_id: T::AccountId,
        pub name: Vec<u8>,
        pub skills: Vec<Skills<T>>
    }

    /// Links to be generated by the candidate and verified by the institution and confirmed by the protocol
    #[derive(Encode, Decode, Clone,TypeInfo,MaxEncodedLen)]
    pub struct VerifiableLink<T: Config> {
        pub candidate_id: T::AccountId,
        pub institution_id: T::AccountId,
        pub skill_id: Vec<u8>,
        pub verified: bool,
    }

    impl<T: Config> Pallet<T>{

        pub fn do_register_candidate(candidate: Candidate<T>) -> DispatchResult {
            // Check if the candidate is already registered
            ensure!(!Candidates::<T>::contains_key(&candidate.account_id), Error::<T>::NotRegisteredCandidate);
            // Add the candidate to the list of candidates
            Candidates::<T>::insert(&candidate.account_id.clone(), candidate.clone());
            // Emit an event
            Self::deposit_event(Event::CandidateAdded { candidate: candidate.account_id });
            Ok(())
        }

        pub fn do_register_certificate(certificate: Certificate<T>) -> DispatchResult {
            // Check if the certificate is already registered
            ensure!(!Certificates::<T>::contains_key(&certificate.account_id), Error::<T>::NotRegisteredCandidate);
            // Add the certificate to the list of certificates
            Certificates::<T>::insert(&certificate.account_id.clone(), certificate.clone());
            // Emit an event
            Self::deposit_event(Event::CertificateAdded { certificate: certificate.account_id });
            Ok(())
        }

        pub fn do_register_institution(institution: Institution<T>) -> DispatchResult {
            // Check if the institution is already registered
            ensure!(!Institutions::<T>::contains_key(&institution.account_id), Error::<T>::NotRegisteredInstitution);
            Institutions::<T>::insert(&institution.account_id.clone(), institution.clone());

            Self::deposit_event(Event::InsitutionAdded { institution: institution.account_id});
            Ok(())
        }

        pub fn do_generate_verifiable_link(candidate_id: T::AccountId, institution_id: T::AccountId) -> DispatchResult {

            Ok(())
        }
    }
}